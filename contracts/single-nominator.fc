const BOUNCEABLE = 0x18;
const ADDRESS_SIZE = 256;
const MIN_TON_FOR_STORAGE = 10000000000; ;; 10TON

;; admin ops
const OP::SEND_RAW_MSG = 0x1000;
const OP::UPGRADE = 0x1001;
const OP::AFTER_UPGRADE = 0x1002;
const OP::CHANGE_VALIDATOR_ADDRESS = 0x1003;
const OP::WITHDRAW = 0x1004;

;; elector ops
const OP::NEW_STAKE = 0x4e73744b;
const OP::RECOVER_STAKE = 0x47657424;

;; modes
const MODE::PAY_FEE_SEPARATELY = 1;
const MODE::SEND_MODE_REMAINING_AMOUNT = 64;

;; errors
const ERROR::WRONG_FIREWALL_WC = 0x2000;
const ERROR::WRONG_QUERY_ID = 0x2001;
const ERROR::WRONG_SET_CODE = 0x2002;
const ERROR::WRONG_VALDIATOR_WC = 0x2003;
const ERROR::INSUFFICENT_BALANCE = 0x2004;

slice make_address(int wc, int addr) inline_ref {
    return begin_cell()
           .store_uint(4, 3).store_int(wc, 8).store_uint(addr, ADDRESS_SIZE).end_cell().begin_parse();
}

slice elector_address() inline_ref {
    int elector = config_param(1).begin_parse().preload_uint(ADDRESS_SIZE);
    return make_address(-1, elector);
}

_ load_data() {
  var cs = get_data().begin_parse();
  var res = (
    cs~load_msg_addr(), ;; owner
    cs~load_msg_addr() ;; validator
  );
  cs.end_parse();
  return res;
}

_ save_data(slice owner, slice validator) impure {
  return begin_cell()
    .store_slice(owner)
    .store_slice(validator)
    .end_cell().set_data();
}


() send_msg(slice to_address, int amount, cell payload, int flags, int send_mode) impure inline_ref {
    int has_payload = ~ cell_null?(payload);

    builder msg = begin_cell()
        .store_uint(flags, 6)
        .store_slice(to_address)
        .store_coins(amount)
        .store_uint(has_payload ? 1 : 0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

    if (has_payload) {
        msg = msg.store_ref(payload);
    }

    send_raw_message(msg.end_cell(), send_mode);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg_cell.begin_parse();
  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  if (flags & 1) {
    ;; ignore all bounced messages
    return ();
  }
  var sender = cs~load_msg_addr();

  if (in_msg.slice_empty?()) {
    return ();
  }

  var (owner, validator) = load_data();

  int op = in_msg~load_uint(32);
  int query_id = in_msg~load_uint(64);

  ;; validator role - the wallet whose private key is on the validator node (can sign blocks but can't steal the funds used for stake)
  if (equal_slices(sender , validator)) {

    ;; send stake to the elector for the next validation cycle (sent every period ~18 hours)
    if (op == OP::NEW_STAKE) {
		(int wc, _) = parse_std_addr(sender);
		(int my_wc, _) = parse_std_addr(my_address());
		throw_unless(ERROR::WRONG_FIREWALL_WC, my_wc == -1);
	    throw_unless(ERROR::WRONG_VALDIATOR_WC, wc == -1); ;; for voting purpose
        throw_unless(ERROR::WRONG_QUERY_ID, query_id); ;;query_id must be greater then 0 to receive confirmation message from elector
        int value = in_msg~load_coins();
		throw_unless(ERROR::INSUFFICENT_BALANCE, value < my_balance - MIN_TON_FOR_STORAGE);
        send_msg(elector_address(), value, begin_cell().store_uint(op, 32).store_uint(query_id, 64).store_slice(in_msg).end_cell(), BOUNCEABLE, MODE::SEND_MODE_REMAINING_AMOUNT); ;; pay fee separately, revert on errors
    }

    ;; recover stake from elector of previous validation cycle (sent every period ~18 hours)
    elseif (op == OP::RECOVER_STAKE) {
        cell payload = begin_cell().store_uint(OP::RECOVER_STAKE, 32).store_uint(query_id, 64).end_cell();
        send_msg(elector_address(), 0, payload, BOUNCEABLE, MODE::SEND_MODE_REMAINING_AMOUNT); ;; bounceable,  carry all the remaining value of the inbound message, fee deducted from amount, revert on errors
    }
  }

  ;; owner role - cold wallet (private key that is not connected to the internet) that owns the funds used for staking and acts as the single nominator
  elseif (equal_slices(sender , owner)) {

	;; allow owner to withdraw funds - take the money home and stop validating with it
    if (op == OP::WITHDRAW) {
      int amount = in_msg~load_coins();
      send_msg(owner, amount, begin_cell().end_cell(), BOUNCEABLE, MODE::SEND_MODE_REMAINING_AMOUNT);
    }

	;; mainly used when the validator was compromised to prevent validator from entering new election cycles
    elseif (op == OP::CHANGE_VALIDATOR_ADDRESS) {
      validator = in_msg~load_msg_addr();
    }

	;; emergency safeguard to allow owner to send arbitrary messages as the nominator contract
    elseif (op == OP::SEND_RAW_MSG) {
        int mode = in_msg~load_uint(8);
        cell msg = in_msg~load_ref();
        send_raw_message(msg, mode);
    }

	;; second emergency safeguard to allow owner to replace nominator logic - you should never need to use this
    elseif (op == OP::UPGRADE) {
        cell code = in_msg~load_ref();
        throw_if(ERROR::WRONG_SET_CODE, cell_null?(code));
        set_code(code);
        cell payload = begin_cell().store_uint(OP::AFTER_UPGRADE, 32).store_uint(query_id, 64).end_cell();
        send_msg(owner, 0, payload, BOUNCEABLE, MODE::SEND_MODE_REMAINING_AMOUNT);
    }

  }

  save_data(owner, validator); ;; TODO: move to CHANGE_VALIDATOR_ADDRESS
}


;; Get methods
(slice, slice) get_roles() method_id {
  var (owner, validator) = load_data();
  return (owner, validator);
}

_ get_pool_data() method_id {

	;; TODO: change type to be compatible with nominator pool
	return (
        2, ;; state - funds staked at elector and should be recovered by mytonctrl
        1, ;; nominators_count - owner is the single nominator
        0, ;; stake_amount_sent - unused, mytonctrl does not rely on this param
        0, ;; validator_amount - unused, since gas is always paid by validator there is no concept of validator_amount
        (0, 0, 0, 0, 0), ;; pool config - unused, since not inviting third party nominators
        0, ;; nominators - unused, mytonctrl does not rely on this param
        0, ;; withdraw_requests - unused, not needed since owner controls the validator
        0, ;; stake_at - back in the past so mytonctrl will always attempt to recover stake
        0, ;; saved_validator_set_hash - unused, required for maintaining validator_amount that we don't need
        2, ;; validator_set_changes_count - unused, required for maintaining validator_amount that we don't need
        0, ;; validator_set_change_time - unused, required for maintaining validator_amount that we don't need
        0, ;; stake_held_for - back in the past so mytonctrl will always attempt to recover stake
        0 ;; config_proposal_votings - unused, not needed since owner controls the validator
    );
}

